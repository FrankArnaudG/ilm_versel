// app/api/payments/alma/webhook/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/db';
import crypto from 'crypto';

/**
 * ============================================
 * POST - WEBHOOK ALMA (IPN - Instant Payment Notification)
 * ============================================
 * 
 * Cette route re√ßoit les notifications Alma en temps r√©el
 * pour mettre √† jour le statut des paiements.
 * 
 * Documentation : https://docs.getalma.eu/docs/webhooks
 */

export async function POST(req: NextRequest) {
  try {
    console.log('\nüîî ========================================');
    console.log('üîî WEBHOOK ALMA RE√áU');
    console.log('üîî ========================================\n');

    // ----------------------------------------
    // 1. R√âCUP√âRER ET PARSER LES DONN√âES
    // ----------------------------------------
    const body = await req.text();
    const signature = req.headers.get('x-alma-signature');

    console.log('üì© Webhook re√ßu');
    console.log('üîê Signature:', signature);

    // ‚ö†Ô∏è IMPORTANT: En production, TOUJOURS v√©rifier la signature
    // if (!signature || !verifyAlmaSignature(body, signature)) {
    //   console.error('‚ùå Signature invalide');
    //   return NextResponse.json(
    //     { error: 'Signature invalide' },
    //     { status: 401 }
    //   );
    // }

    const webhookData = JSON.parse(body);
    
    console.log('üìã Type d\'√©v√©nement:', webhookData.type);
    console.log('üí≥ Payment ID:', webhookData.data?.id);

    // ----------------------------------------
    // 2. TRAITER L'√âV√âNEMENT
    // ----------------------------------------
    
    switch (webhookData.type) {
      case 'payment.authorized':
        await handlePaymentAuthorized(webhookData.data);
        break;

      case 'payment.captured':
        await handlePaymentCaptured(webhookData.data);
        break;

      case 'payment.failed':
        await handlePaymentFailed(webhookData.data);
        break;

      case 'payment.refunded':
        await handlePaymentRefunded(webhookData.data);
        break;

      default:
        console.log('‚ö†Ô∏è Type d\'√©v√©nement non g√©r√©:', webhookData.type);
    }

    // ----------------------------------------
    // 3. R√âPONSE
    // ----------------------------------------
    console.log('‚úÖ Webhook trait√© avec succ√®s\n');

    return NextResponse.json({ 
      success: true,
      received: true 
    });

  } catch (error) {
    console.error('\n‚ùå ========================================');
    console.error('‚ùå ERREUR TRAITEMENT WEBHOOK ALMA');
    console.error('‚ùå ========================================');
    console.error(error);
    console.error('‚ùå ========================================\n');

    return NextResponse.json(
      { 
        success: false,
        error: 'Erreur traitement webhook' 
      },
      { status: 500 }
    );
  }
}

// ============================================
// GESTIONNAIRES D'√âV√âNEMENTS
// ============================================

/**
 * Paiement autoris√© (client a valid√© sur Alma)
 */
async function handlePaymentAuthorized(paymentData: any) {
  console.log('‚úÖ Paiement autoris√©:', paymentData.id);

  try {
    // R√©cup√©rer le paiement en base
    const payment = await db.payment.findFirst({
      where: { providerPaymentId: paymentData.id },
      include: { order: true }
    });

    if (!payment) {
      console.error('‚ùå Paiement introuvable en BDD:', paymentData.id);
      return;
    }

    console.log('üì¶ Commande associ√©e:', payment.order.orderNumber);

    // Mettre √† jour le paiement
    await db.payment.update({
      where: { id: payment.id },
      data: {
        status: 'PROCESSING',
        processedAt: new Date(),
        metadata: {
          ...(payment.metadata as any),
          alma_state: paymentData.state,
          authorized_at: new Date().toISOString()
        }
      }
    });

    // Mettre √† jour la commande
    await db.order.update({
      where: { id: payment.orderId },
      data: {
        status: 'CONFIRMED',
        paymentStatus: 'PROCESSING'
      }
    });

    // Historique
    await db.orderStatusHistory.create({
      data: {
        orderId: payment.orderId,
        fromStatus: 'PENDING',
        toStatus: 'CONFIRMED',
        note: `Paiement Alma autoris√© - ${paymentData.id}`
      }
    });

    console.log('‚úÖ Paiement marqu√© comme autoris√©');

  } catch (error) {
    console.error('‚ùå Erreur handlePaymentAuthorized:', error);
    throw error;
  }
}

/**
 * Paiement captur√© (argent re√ßu)
 */
async function handlePaymentCaptured(paymentData: any) {
  console.log('üí∞ Paiement captur√©:', paymentData.id);

  try {
    // R√©cup√©rer le paiement en base
    const payment = await db.payment.findFirst({
      where: { providerPaymentId: paymentData.id },
      include: { order: true }
    });

    if (!payment) {
      console.error('‚ùå Paiement introuvable en BDD:', paymentData.id);
      return;
    }

    console.log('üì¶ Commande associ√©e:', payment.order.orderNumber);

    // Mettre √† jour le paiement
    await db.payment.update({
      where: { id: payment.id },
      data: {
        status: 'SUCCEEDED',
        processedAt: new Date(),
        metadata: {
          ...(payment.metadata as any),
          alma_state: paymentData.state,
          captured_at: new Date().toISOString()
        }
      }
    });

    // Mettre √† jour la commande
    await db.order.update({
      where: { id: payment.orderId },
      data: {
        status: 'CONFIRMED',
        paymentStatus: 'SUCCEEDED',
        paidAt: new Date()
      }
    });

    // Historique
    await db.orderStatusHistory.create({
      data: {
        orderId: payment.orderId,
        fromStatus: 'CONFIRMED',
        toStatus: 'CONFIRMED',
        note: `Paiement Alma confirm√© - ${paymentData.id}`
      }
    });

    console.log('‚úÖ Paiement marqu√© comme r√©ussi');

    // TODO: D√©clencher les actions post-paiement
    // - Envoyer email de confirmation
    // - Notifier l'√©quipe
    // - Mettre √† jour le stock
    // - G√©n√©rer l'√©tiquette de livraison

  } catch (error) {
    console.error('‚ùå Erreur handlePaymentCaptured:', error);
    throw error;
  }
}

/**
 * Paiement √©chou√©
 */
async function handlePaymentFailed(paymentData: any) {
  console.log('‚ùå Paiement √©chou√©:', paymentData.id);

  try {
    // R√©cup√©rer le paiement en base
    const payment = await db.payment.findFirst({
      where: { providerPaymentId: paymentData.id },
      include: { order: true }
    });

    if (!payment) {
      console.error('‚ùå Paiement introuvable en BDD:', paymentData.id);
      return;
    }

    console.log('üì¶ Commande associ√©e:', payment.order.orderNumber);

    // Mettre √† jour le paiement
    await db.payment.update({
      where: { id: payment.id },
      data: {
        status: 'FAILED',
        failedAt: new Date(),
        metadata: {
          ...(payment.metadata as any),
          alma_state: paymentData.state,
          failure_reason: paymentData.reason || 'unknown',
          failed_at: new Date().toISOString()
        }
      }
    });

    // Mettre √† jour la commande
    await db.order.update({
      where: { id: payment.orderId },
      data: {
        status: 'CANCELLED',
        paymentStatus: 'FAILED'
      }
    });

    // Historique
    await db.orderStatusHistory.create({
      data: {
        orderId: payment.orderId,
        fromStatus: 'PENDING',
        toStatus: 'CANCELLED',
        note: `Paiement Alma √©chou√© - ${paymentData.id}`
      }
    });

    console.log('‚úÖ Paiement marqu√© comme √©chou√©');

  } catch (error) {
    console.error('‚ùå Erreur handlePaymentFailed:', error);
    throw error;
  }
}

/**
 * Paiement rembours√©
 */
async function handlePaymentRefunded(paymentData: any) {
  console.log('üí∏ Paiement rembours√©:', paymentData.id);

  try {
    // R√©cup√©rer le paiement en base
    const payment = await db.payment.findFirst({
      where: { providerPaymentId: paymentData.id },
      include: { order: true }
    });

    if (!payment) {
      console.error('‚ùå Paiement introuvable en BDD:', paymentData.id);
      return;
    }

    console.log('üì¶ Commande associ√©e:', payment.order.orderNumber);

    // V√©rifier si c'est un remboursement total ou partiel
    const isFullRefund = paymentData.refunded_amount === payment.amount;

    // Mettre √† jour le paiement
    await db.payment.update({
      where: { id: payment.id },
      data: {
        status: isFullRefund ? 'REFUNDED' : 'PARTIALLY_REFUNDED',
        refundedAt: new Date(),
        metadata: {
          ...(payment.metadata as any),
          alma_state: paymentData.state,
          refunded_amount: paymentData.refunded_amount,
          refunded_at: new Date().toISOString()
        }
      }
    });

    // Mettre √† jour la commande
    await db.order.update({
      where: { id: payment.orderId },
      data: {
        status: 'REFUNDED',
        paymentStatus: isFullRefund ? 'REFUNDED' : 'PARTIALLY_REFUNDED'
      }
    });

    // Historique
    await db.orderStatusHistory.create({
      data: {
        orderId: payment.orderId,
        toStatus: 'REFUNDED',
        note: `Paiement Alma rembours√© (${isFullRefund ? 'total' : 'partiel'}) - ${paymentData.id}`
      }
    });

    console.log(`‚úÖ Paiement marqu√© comme rembours√© (${isFullRefund ? 'total' : 'partiel'})`);

  } catch (error) {
    console.error('‚ùå Erreur handlePaymentRefunded:', error);
    throw error;
  }
}

// ============================================
// V√âRIFICATION DE SIGNATURE (OPTIONNEL MAIS RECOMMAND√â)
// ============================================

/**
 * V√©rifier la signature du webhook Alma
 * 
 * Documentation: https://docs.getalma.eu/docs/webhooks#verifying-signatures
 */
function verifyAlmaSignature(payload: string, signature: string): boolean {
  try {
    const almaApiKey = process.env.ALMA_API_KEY_TEST || process.env.ALMA_API_KEY_LIVE;
    
    if (!almaApiKey) {
      console.error('‚ö†Ô∏è Cl√© API Alma manquante pour v√©rification signature');
      return false;
    }

    // Calculer le HMAC
    const expectedSignature = crypto
      .createHmac('sha256', almaApiKey)
      .update(payload)
      .digest('hex');

    // Comparer les signatures
    return crypto.timingSafeEqual(
      Buffer.from(signature),
      Buffer.from(expectedSignature)
    );

  } catch (error) {
    console.error('‚ùå Erreur v√©rification signature:', error);
    return false;
  }
}